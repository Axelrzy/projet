#include <AccelStepper.h>


#define vitessePourReplacement 400 //step per second
#define mmParStepX 0.01
#define mmParStepY 0.0075
#define verinPIN 10
#define capteurXPIN 11
#define capteurYPIN 12
#define machinePIN 5


AccelStepper stepper(1, 7, 6);// direction Digital 6 (CCW), pulses Digital 7 (CLK)
AccelStepper stepper2(1, 9, 8);


String val;
int v, n, l, e, c, t_acc;
int origine_x = 0, origine_y = 0, origine_x_step = origine_x / mmParStepX , origine_y_step = origine_y / mmParStepY, acc_en_step;
int n_restant, c_restant, cycle_effectue = 0, longueur_en_step, espacement_en_step, v_en_step ;
char a;
int tps_insert_contact = 0, tps_insert_non_contact = 0;
boolean contact = false, premiere_finOrigine = false;

void enableDisableMotor();
void origine();


void setup() {
  // put your setup code here, to run once:
  Serial.begin(115200);
  Serial.setTimeout(100);                 //pour un Serial.readString() on va mettre 100ms au lieu de 1000ms
  pinMode(verinPIN, OUTPUT);
  pinMode(capteurXPIN, INPUT);
  pinMode(capteurYPIN, INPUT);
  pinMode(machinePIN, OUTPUT);

  digitalWrite(machinePIN, LOW);
  digitalWrite(verinPIN, HIGH);


  stepper.setMaxSpeed(3000);
  stepper.setAcceleration(3000); //ACCELERATION = Steps /(second)^2
  stepper2.setMaxSpeed(3000);
  stepper2.setAcceleration(3000);
  stepper.setMinPulseWidth(20);
  stepper2.setMinPulseWidth(20);


}

void loop() {

  lectureSerial();                //On regarde si une valeur a été reçu sur le Serial, si une valeur a été reçu alors on agit
  enableDisableMotor();           //on permet au moteur ou non de run ou pas, si il ne run pas alors on disable les sorties
  updateTraces();                 //On met à jour le nombre de traces dans le cycle en mettant les moteur au bons endroits
  updatecycles();                 //On met à jour le nombre de cycle en revenant ou non au point de départ pour recommencer un cycle ou non
  updateTempsContact();           //On met à jour le temps ou l'insert est en contact avec la plaque
  finRun();                       //Si aucun moteur ne tourne, qu'il n'y a plus de traces à faire et qu'ils ne sont pas à l'origine alors ils y vont
  finOrigine();                   //Si on appuie sur le bouton origine et que les moteurs sont à l'origne alors on envoie à l'interface que la manoeuvre est fini
}


void origine() {
  if (digitalRead(capteurXPIN) != HIGH || digitalRead(capteurYPIN) != HIGH) {
    stepper.setMaxSpeed(400);
    stepper.setAcceleration(100000);
    stepper.move(-100000);
    stepper2.setMaxSpeed(400);
    stepper2.setAcceleration(100000);
    stepper2.move(-100000);
    while (digitalRead(capteurXPIN) != HIGH || digitalRead(capteurYPIN) != HIGH) {
      enableDisableMotor();
      if (digitalRead(capteurYPIN) == HIGH) {
        stepper2.stop();
      }
      if (digitalRead(capteurXPIN) == HIGH) {
        stepper.stop();
      }
    }
    stepper.stop();
    stepper2.stop();

    stepper.setCurrentPosition(0);
    stepper2.setCurrentPosition(0);

  }
}



void enableDisableMotor() {
  if (stepper.distanceToGo() != 0 )
  {
    stepper.enableOutputs(); //enable pins
    stepper.run(); //step the motor (this will step the motor by 1 step at each loop)
  }
  else
  {
    stepper.disableOutputs(); //disable outputs
  }

  if (stepper2.distanceToGo() != 0 )
  {
    stepper2.enableOutputs(); //enable pins
    stepper2.run(); //step the motor (this will step the motor by 1 step at each loop)
  }
  else
  {
    stepper2.disableOutputs(); //disable outputs
  }
}




void lectureSerial() {

  if (Serial.available() > 0) {
    val = "";
    char charactere_rcv = 0;
    charactere_rcv = Serial.read();
    while (charactere_rcv != '$') {                 //Chaque chaine de caractère envoyé contient un $ qui marque la fin
      val = val + (String)charactere_rcv;
      charactere_rcv = Serial.read();
    }



    if (val == "Debut") {
      origine();
    }


    else if (val == "Origine") {
      v = 0;

      if (digitalRead(verinPIN) == LOW || digitalRead(machinePIN) == HIGH) {
        digitalWrite(verinPIN, HIGH);
        digitalWrite(machinePIN, LOW);
        delay(3000);
      }
      stepper.setMaxSpeed(vitessePourReplacement); //set speed
      stepper.setAcceleration(vitessePourReplacement);
      stepper.moveTo(origine_x_step);
      stepper2.setMaxSpeed(vitessePourReplacement); //set speed
      stepper2.setAcceleration(vitessePourReplacement);
      stepper2.moveTo(origine_y_step);
      premiere_finOrigine = true;

    }

    else if (val == "Stop") {
      v = 0;
      digitalWrite(machinePIN, LOW);
      stepper.setAcceleration(100000);     //Le stop va permettre au moteur de s'arreter au plus vite en fonction de l'acceleration et la decceleration
      stepper2.setAcceleration(100000);    // en une acceleration rapide on arrete les moteurs plus rapidement
      stepper.stop();
      stepper2.stop();
      contact = false;

    }
    else if (val.indexOf("x=") >= 0) {
      sscanf (val.c_str(), "x=%d", &origine_x);
      origine_x_step = origine_x / mmParStepX;
      stepper.setMaxSpeed(vitessePourReplacement);        //on augmente de1mm l'origine de l'axe x
      stepper.setAcceleration(vitessePourReplacement);
      stepper.moveTo(origine_x_step);
      v = 0;


    }
    else if (val.indexOf("y=") >= 0) {
      sscanf (val.c_str(), "y=%d", &origine_y);
      origine_y_step = origine_y / mmParStepY;
      stepper2.setMaxSpeed(vitessePourReplacement);     //on augmente de 1mm l'origine de l'axe y
      stepper2.setAcceleration(vitessePourReplacement);
      stepper2.moveTo(origine_y_step);
      v = 0;

    }
    else if (val.length() != 0) {
      sscanf (val.c_str(), "v:%d n:%d l:%d e:%d c:%d a:%c x:%d y:%d t:%d", &v, &n, &l, &e, &c, &a, &origine_x, &origine_y, &t_acc);    //On reçoit les données via l'interface et on les stocks dans les valeurs
      n_restant = n;               //il nous reste donc n trace a faire dans ce cycle
      c_restant = c - 1;           //le moins 1 car sinon il fait un cycle en trop

      if (a == 'x') {
        longueur_en_step = l / mmParStepX;
        espacement_en_step = e / mmParStepY;
        v_en_step =  v / mmParStepX;
      } else {
        longueur_en_step = l / mmParStepY;
        espacement_en_step = e / mmParStepX;
        v_en_step =  v / mmParStepY;
      }

      acc_en_step = (v_en_step) / (t_acc * 0.001);             //On calcule l'acceleration avec a = v/t. On multiplie par 1000 car on prend t en ms, or v et en s
      origine_x_step = origine_x / mmParStepX;
      origine_y_step = origine_y / mmParStepY;
      stepper.setMaxSpeed(vitessePourReplacement); //set speed
      stepper.setAcceleration(vitessePourReplacement);
      stepper.moveTo(origine_x_step); //set relative distance and direction
      stepper2.setMaxSpeed(vitessePourReplacement); //set speed
      stepper2.setAcceleration(vitessePourReplacement);
      stepper2.moveTo(origine_y_step); //set relative distance and direction

    }
  }

}







void updateTraces() {
  if (n_restant != 0 && stepper.speed() == 0 && stepper2.speed() == 0 && v != 0) {
    contact = false;
    Serial.println(tps_insert_contact);
    Serial.println(cycle_effectue);
    Serial.write('r');      //r pour running
    updateTempsContact();
    if (a == 'x') {
      if (stepper.currentPosition() == origine_x_step) {
        digitalWrite(verinPIN, LOW);
        delay(3000);
        digitalWrite(machinePIN, HIGH);
        updateTempsContact();
        stepper.setMaxSpeed(v_en_step); //set speed
        stepper.setAcceleration(acc_en_step);
        stepper.moveTo(longueur_en_step + origine_x_step); //set relative distance and direction
        contact = true;

      } else {
        digitalWrite(verinPIN, HIGH);
        digitalWrite(machinePIN, LOW);
        delay(3000);
        updateTempsContact();
        stepper.setMaxSpeed(vitessePourReplacement); //set speed
        stepper.setAcceleration(vitessePourReplacement);
        stepper.moveTo(origine_x_step); //set relative distance and direction
        if (n_restant != 1) {
          stepper2.setMaxSpeed(vitessePourReplacement); //set speed
          stepper2.setAcceleration(vitessePourReplacement);
          stepper2.move(espacement_en_step); //set relative distance and direction
        }
        n_restant = n_restant - 1;
      }

    } else {
      if (stepper2.currentPosition() == origine_y_step) {
        digitalWrite(verinPIN, LOW);
        delay(3000);
        digitalWrite(machinePIN, HIGH);
        updateTempsContact();
        stepper2.setMaxSpeed(v_en_step); //set speed
        stepper2.setAcceleration(acc_en_step);
        stepper2.moveTo(longueur_en_step + origine_y_step); //set relative distance and direction
        contact = true;

      } else {
        digitalWrite(verinPIN, HIGH);
        digitalWrite(machinePIN, LOW);
        delay(3000);
        updateTempsContact();
        stepper2.setMaxSpeed(vitessePourReplacement); //set speed
        stepper2.setAcceleration(vitessePourReplacement);
        stepper2.moveTo(origine_y_step); //set relative distance and direction
        if (n_restant != 1) {
          stepper.setMaxSpeed(vitessePourReplacement); //set speed
          stepper.setAcceleration(vitessePourReplacement);
          stepper.move(espacement_en_step); //set relative distance and direction
        }
        n_restant = n_restant - 1;
      }
    }

  }
}


void updatecycles() {
  if (n_restant ==  0 && c_restant != 0 && stepper.speed() == 0 && stepper2.speed() == 0) {
    delay(3000);
    n_restant = n;
    c_restant--;
    cycle_effectue++;
    if (a == 'x') {
      stepper2.setMaxSpeed(vitessePourReplacement); //set speed
      stepper2.setAcceleration(vitessePourReplacement);
      stepper2.moveTo(origine_y_step);
    } else {
      stepper.setMaxSpeed(vitessePourReplacement); //set speed
      stepper.setAcceleration(vitessePourReplacement);
      stepper.moveTo(origine_x_step);
    }
  }
}



void updateTempsContact() {
  if (contact) {
    tps_insert_contact = millis() / 1000 - tps_insert_non_contact;
  } else {
    tps_insert_non_contact = millis() / 1000 - tps_insert_contact;
  }
}

void finRun() {
  if (n_restant ==  0 && c_restant == 0 && stepper.speed() == 0 && stepper2.speed() == 0 && v != 0) {
    stepper.setMaxSpeed(vitessePourReplacement); //set speed
    stepper.setAcceleration(vitessePourReplacement);
    stepper.moveTo(origine_x_step);
    stepper2.setMaxSpeed(vitessePourReplacement); //set speed
    stepper2.setAcceleration(vitessePourReplacement);
    stepper2.moveTo(origine_y_step);
    if (stepper.currentPosition() == origine_x_step && stepper2.currentPosition() == origine_y_step) {
      cycle_effectue++;
      Serial.println(tps_insert_contact);
      Serial.println(cycle_effectue);
      Serial.write('d');    //d pour done
      v = 0;
    }
  }
}


void finOrigine() {
  if (val == "Origine" && premiere_finOrigine && stepper.speed() == 0 && stepper2.speed() == 0) {
    Serial.println(tps_insert_contact);
    Serial.println(cycle_effectue);
    Serial.write('d');                         //d pour done
    premiere_finOrigine = false;
  }
}
